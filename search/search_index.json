{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Roact is a declarative Lua UI library similar to Facebook's React. It exposes a very similar API and implements nearly identical semantics.</p> <p>This documentation is based on the structure of React's documentation, but is a work in progress. Many things from React also apply to Roact, but if you find anything missing or incorrect, open an issue on GitHub!</p> <p>Info</p> <p>This documentation assumes some familiarity with Lua. If you're new to Lua, Programming in Lua by Roberto Ierusalimschy is a good introduction, and the first edition (for Lua 5.0) is available online for free.</p>"},{"location":"api-reference/","title":"API Reference","text":""},{"location":"api-reference/#methods","title":"Methods","text":""},{"location":"api-reference/#roactcreateelement","title":"Roact.createElement","text":"<pre><code>Roact.createElement(component, [props, [children]]) -&gt; RoactElement\n</code></pre> <p>Creates a new Roact element representing the given <code>component</code>. Elements are lightweight descriptions about what a Roblox Instance should look like, like a blueprint!</p> <p>The <code>children</code> argument is shorthand for adding a <code>Roact.Children</code> key to <code>props</code>. It should be specified as a dictionary of names to elements.</p> <p><code>component</code> can be a string, a function, or a table created by <code>Component:extend</code>.</p> <p>Caution</p> <p>Make sure not to modify <code>props</code> or <code>children</code> after they're passed into <code>createElement</code>!</p>"},{"location":"api-reference/#roactcreatefragment","title":"Roact.createFragment","text":"<p>Added in Roact 1.0.0</p> <pre><code>Roact.createFragment(elements) -&gt; RoactFragment\n</code></pre> <p>Creates a new Roact fragment with the provided table of elements. Fragments allow grouping of elements without the need for intermediate containing objects like <code>Frame</code>s.</p> <p>Caution</p> <p>Make sure not to modify <code>elements</code> after they're passed into <code>createFragment</code>!</p>"},{"location":"api-reference/#roactmount","title":"Roact.mount","text":"<pre><code>Roact.mount(element, [parent, [key]]) -&gt; RoactTree\n</code></pre> <p>Info</p> <p><code>Roact.mount</code> is also available via the deprecated alias <code>Roact.reify</code>. It will be removed in a future release.</p> <p>Creates a Roblox Instance given a Roact element, and optionally a <code>parent</code> to put it in, and a <code>key</code> to use as the instance's <code>Name</code>.</p> <p>The result is a <code>RoactTree</code>, which is an opaque handle that represents a tree of components owned by Roact. You can pass this to APIs like <code>Roact.unmount</code>. It'll also be used for future debugging APIs.</p>"},{"location":"api-reference/#roactupdate","title":"Roact.update","text":"<pre><code>Roact.update(tree, element) -&gt; RoactTree\n</code></pre> <p>Info</p> <p><code>Roact.update</code> is also available via the deprecated alias <code>Roact.reconcile</code>. It will be removed in a future release.</p> <p>Updates an existing instance handle with a new element, returning a new handle. This can be used to update a UI created with <code>Roact.mount</code> by passing in a new element with new props.</p> <p><code>update</code> can be used to change the props of a component instance created with <code>mount</code> and is useful for putting Roact content into non-Roact applications.</p> <p>As of Roact 1.0, the returned <code>RoactTree</code> object will always be the same value as the one passed in.</p>"},{"location":"api-reference/#roactunmount","title":"Roact.unmount","text":"<pre><code>Roact.unmount(tree) -&gt; void\n</code></pre> <p>Info</p> <p><code>Roact.unmount</code> is also available via the deprecated alias <code>Roact.teardown</code>. It will be removed in a future release.</p> <p>Destroys the given <code>RoactTree</code> and all of its descendants. Does not operate on a Roblox Instance -- this must be given a handle that was returned by <code>Roact.mount</code>.</p>"},{"location":"api-reference/#roactonechild","title":"Roact.oneChild","text":"<p><code>Roact.oneChild(children) -&gt; RoactElement | nil</code></p> <p>Given a dictionary of children, returns a single child element.</p> <p>If <code>children</code> contains more than one child, <code>oneChild</code> function will throw an error. This is intended to denote an error when using the component using <code>oneChild</code>.</p> <p>If <code>children</code> is <code>nil</code> or contains no children, <code>oneChild</code> will return <code>nil</code>.</p>"},{"location":"api-reference/#roactcreatebinding","title":"Roact.createBinding","text":"<p>Added in Roact 1.0.0</p> <pre><code>Roact.createBinding(initialValue) -&gt; Binding, updateFunction\nwhere\n    updateFunction: (newValue) -&gt; ()\n</code></pre> <p>The first value returned is a <code>Binding</code> object, which will typically be passed as a prop to a Roact host component. The second is a function that can be called with a new value to update the binding.</p> <p>A <code>Binding</code> has the following API:</p>"},{"location":"api-reference/#getvalue","title":"getValue","text":"<pre><code>Binding:getValue() -&gt; value\n</code></pre> <p>Returns the internal value of the binding. This is helpful when updating a binding relative to its current value.</p> <p>Warning</p> <p>Using <code>getValue</code> inside a component's <code>render</code> method is dangerous! Using the unwrapped value directly won't allow Roact to subscribe to a binding's updates. To guarantee that a bound value will update, use the binding itself for your prop value.</p>"},{"location":"api-reference/#map","title":"map","text":"<pre><code>Binding:map(mappingFunction) -&gt; Binding\nwhere\n    mappingFunction: (value) -&gt; mappedValue\n</code></pre> <p>Returns a new binding that maps the existing binding's value to something else. For example, <code>map</code> can be used to transform an animation progress value like <code>0.4</code> into a property that can be consumed by a Roblox Instance like <code>UDim2.new(0.4, 0, 1, 0)</code>.</p>"},{"location":"api-reference/#roactjoinbindings","title":"Roact.joinBindings","text":"<p>Added in Roact 1.1.0</p> <pre><code>Roact.joinBindings(bindings) -&gt; Binding\nwhere\n    bindings: { [any]: Binding }\n</code></pre> <p>Combines multiple bindings into a single binding. The new binding's value will have the same keys as the input table of bindings.</p> <p><code>joinBindings</code> is usually used alongside <code>Binding:map</code>:</p> <pre><code>local function Flex()\n    local aSize, setASize = Roact.createBinding(Vector2.new())\n    local bSize, setBSize = Roact.createBinding(Vector2.new())\n\n    return Roact.createElement(\"Frame\", {\n        Size = Roact.joinBindings({aSize, bSize}):map(function(sizes)\n            local sum = Vector2.new()\n\n            for _, size in ipairs(sizes) do\n                sum = sum + size\n            end\n\n            return UDim2.new(0, sum.X,  0, sum.Y)\n        end),\n    }, {\n        A = Roact.createElement(\"Frame\", {\n            Size = UDim2.new(1, 0, 0, 30),\n            [Roact.Change.AbsoluteSize] = function(instance)\n                setASize(instance.Size)\n            end,\n        }),\n        B = Roact.createElement(\"Frame\", {\n            Size = UDim2.new(1, 0, 0, 30),\n            Position = aSize:map(function(size)\n                return UDim2.new(0, 0, 0, size.Y)\n            end),\n            [Roact.Change.AbsoluteSize] = function(instance)\n                setBSize(instance.Size)\n            end,\n        }),\n    })\nend\n</code></pre>"},{"location":"api-reference/#roactcreateref","title":"Roact.createRef","text":"<pre><code>Roact.createRef() -&gt; Ref\n</code></pre> <p>Creates a new reference object that can be used with Roact.Ref.</p>"},{"location":"api-reference/#roactforwardref","title":"Roact.forwardRef","text":"<p>Added in Roact 1.4.0</p> <pre><code>Roact.forwardRef(render: (props: table, ref: Ref) -&gt; RoactElement) -&gt; RoactComponent\n</code></pre> <p>Creates a new component given a render function that accepts both props and a ref, allowing a ref to be forwarded to an underlying host component via Roact.Ref.</p>"},{"location":"api-reference/#roactcreatecontext","title":"Roact.createContext","text":"<p>Added in Roact 1.3.0</p> <pre><code>Roact.createContext(defaultValue: any) -&gt; RoactContext\n\ntype RoactContext = {\n    Provider: Component,\n    Consumer: Component,\n    [private fields]\n}\n</code></pre> <p>Creates a new context provider and consumer. For a usage guide, see Advanced Concepts: Context.</p> <p><code>defaultValue</code> is given to consumers if they have no <code>Provider</code> ancestors. It is up to users of Roact's context API to turn this case into an error if it is an invalid state.</p> <p><code>Provider</code> and <code>Consumer</code> are both Roact components.</p>"},{"location":"api-reference/#provider","title":"<code>Provider</code>","text":"<p><code>Provider</code> accepts the following props:</p> <ul> <li><code>value</code>: The value to put into the tree for this context value.<ul> <li>If the <code>Provider</code> is updated with a new <code>value</code>, any matching <code>Consumer</code> components will be re-rendered with the new value.</li> </ul> </li> <li><code>[Children]</code>: Any number of children to render underneath this provider.<ul> <li>Descendants of this component can receive the provided context value by using <code>Consumer</code>.</li> </ul> </li> </ul>"},{"location":"api-reference/#consumer","title":"<code>Consumer</code>","text":"<p><code>Consumer</code> accepts just one prop:</p> <ul> <li><code>render(value) -&gt; RoactElement | nil</code>: A function that will be invoked to render any children.<ul> <li><code>render</code> will be called every time <code>Consumer</code> is rendered.</li> </ul> </li> </ul>"},{"location":"api-reference/#roactsetglobalconfig","title":"Roact.setGlobalConfig","text":"<pre><code>Roact.setGlobalConfig(configValues: Dictionary&lt;string, bool&gt;) -&gt; void\n</code></pre> <p>The entry point for configuring Roact. Roact currently applies this to everything using this instance of Roact, so be careful using this with a project that has multiple consumers of Roact.</p> <p>Once config values are set, they will apply from then on. This is primarily useful when developing as it can enable features that validate your code more strictly. Most of the settings here incur a performance cost and should typically be disabled in production environments.</p> <p>Call this method once at the root of your project (before mounting any Roact elements): <pre><code>Roact.setGlobalConfig({\n    typeChecks = true,\n    propValidation = true,\n})\n</code></pre></p> <p>The following are the valid config keys that can be used, and what they do.</p>"},{"location":"api-reference/#typechecks","title":"typeChecks","text":"<p>Enables type checks for Roact's public interface. This includes some of the following:</p> <ul> <li>Check that the <code>props</code> and <code>children</code> arguments to <code>Roact.createElement</code> are both tables or nil</li> <li>Check that <code>setState</code> is passing <code>self</code> as the first argument (it should be called like <code>self:setState(...)</code>)</li> <li>Confirm the <code>Roact.mount</code>'s first argument is a Roact element</li> <li>And much more!</li> </ul>"},{"location":"api-reference/#internaltypechecks","title":"internalTypeChecks","text":"<p>Enables type checks for internal functionality of Roact. This is typically only useful when debugging Roact itself. It will run similar type checks to those mentioned above, but only the private portion of the API.</p>"},{"location":"api-reference/#elementtracing","title":"elementTracing","text":"<p>When enabled, Roact will capture a stack trace at the site of each element creation and hold onto it, using it to provide additional details on certain kinds of errors. If you get an error that says \"\", try enabling this config value to help with debugging. <p>Enabling <code>elementTracing</code> also allows the use of the getElementTraceback method on Component, which can also be helpful for debugging.</p>"},{"location":"api-reference/#propvalidation","title":"propValidation","text":"<p>Enables validation of props via the validateProps method on components. With this flag enabled, any validation written by component authors in a component's <code>validateProps</code> method will be run on every prop change. This is helpful during development for making sure components are being used correctly.</p>"},{"location":"api-reference/#invalidpropdiscarding","title":"invalidPropDiscarding","text":"<p>Enables discarding of props passed into host components which do not exist on the specified Roblox class, meaning that</p> <pre><code>local exampleElement = Roact.createElement(\"TextLabel\", {\n    InvalidProp = \"This is a prop which does not exist as a property on the TextLabel instance class in Roblox.\"\n})\n</code></pre> <p>will return a variable <code>exampleElement</code> of type <code>TextLabel</code> with default properties.</p>"},{"location":"api-reference/#childmerging","title":"childMerging","text":"<p>Enables automatic merging of <code>props[Roact.Children]</code> and the <code>children</code> argument to <code>createElement</code>. By default, the <code>children</code> argument will take precedence when there are identical keys, meaning that</p> <pre><code>local exampleElement = Roact.createElement(\"Frame\", {\n    [Roact.Children] = {\n        PropsChild = Roact.createElement(\"TextButton\"),\n        ExampleChild = Roact.createElement(\"TextLabel\") -- this is discarded\n    }\n}, {\n    ChildrenChild = Roact.createElement(\"ImageButton\"),\n    ExampleChild = Roact.createElement(\"ImageLabel\")\n})\n</code></pre> <p>will return a variable <code>exampleElement</code> which is a <code>Frame</code> element with children: * A <code>TextButton</code> called <code>PropsChild</code> * An <code>ImageLabel</code> called <code>ExampleChild</code> * An <code>ImageButton</code> called <code>ChildrenChild</code> This behaviour can be changed with <code>propsPrecedence</code>.</p>"},{"location":"api-reference/#propsprecedence","title":"propsPrecedence","text":"<p>Enables <code>props[Roact.Children]</code> taking precedence over the <code>children</code> argument in <code>createElement</code> when there are identical keys, meaning that</p> <pre><code>local exampleElement = Roact.createElement(\"Frame\", {\n    [Roact.Children] = {\n        PropsChild = Roact.createElement(\"TextButton\"),\n        ExampleChild = Roact.createElement(\"TextLabel\")\n    }\n}, {\n    ChildrenChild = Roact.createElement(\"ImageButton\"),\n    ExampleChild = Roact.createElement(\"ImageLabel\") -- this is discarded\n})\n</code></pre> <p>will return a variable <code>exampleElement</code> which is a <code>Frame</code> element with children: * A <code>TextButton</code> called <code>PropsChild</code> * A <code>TextLabel</code> called <code>ExampleChild</code> * An <code>ImageButton</code> called <code>ChildrenChild</code></p>"},{"location":"api-reference/#constants","title":"Constants","text":""},{"location":"api-reference/#roactchildren","title":"Roact.Children","text":"<p>This is the key that Roact uses internally to store the children that are attached to a Roact element.</p> <p>If you're writing a new function component or stateful component that renders children like a host component, you can access <code>Roact.Children</code> in your props table.</p>"},{"location":"api-reference/#roactref","title":"Roact.Ref","text":"<p>Use <code>Roact.Ref</code> as a key into the props of a host element to receive a handle to the underlying Roblox Instance.</p> <p>Assign this key to a ref created with createRef: <pre><code>local ExampleComponent = Roact.Component:extend(\"ExampleComponent\")\n\nfunction ExampleComponent:init()\n    -- Create a ref.\n    self.ref = Roact.createRef()\nend\n\nfunction ExampleComponent:render()\n    return Roact.createElement(\"Frame\", {\n        -- Use the ref to point to this rendered instance.\n        [Roact.Ref] = self.ref,\n    })\nend\n\nfunction ExampleComponent:didMount()\n    -- Refs are a kind of binding, so we can access the Roblox Instance using getValue.\n    print(\"Roblox Instance\", self.ref:getValue())\nend\n</code></pre></p> <p>Info</p> <p>Ref objects have a deprecated field called <code>current</code> that is always equal to the result of <code>getValue</code>. Assigning to the <code>current</code> field is not allowed. The field will be removed in a future release.</p> <p>Alternatively, you can assign it to a function instead: <pre><code>Roact.createElement(\"Frame\", {\n    -- The provided function will be called whenever the rendered instance changes.\n    [Roact.Ref] = function(rbx)\n        print(\"Roblox Instance\", rbx)\n    end,\n})\n</code></pre></p> <p>Warning</p> <p>When <code>Roact.Ref</code> is given a function, Roact does not guarantee when this function will be run relative to the reconciliation of other props. If you try to read a Roblox property that's being set via a Roact prop, you won't know if you're reading it before or after Roact updates that prop!</p> <p>Warning</p> <p>When <code>Roact.Ref</code> is given a function, it will be called with <code>nil</code> when the component instance is destroyed!</p> <p>See the refs guide for more details.</p>"},{"location":"api-reference/#roactevent","title":"Roact.Event","text":"<p>Index into <code>Roact.Event</code> to receive a key that can be used to connect to events when creating host elements:</p> <pre><code>Roact.createElement(\"ImageButton\", {\n    [Roact.Event.MouseButton1Click] = function(rbx, x, y)\n        print(rbx, \"clicked at position\", x, y)\n    end,\n})\n</code></pre> <p>Info</p> <p>Event callbacks receive the Roblox Instance as the first parameter, followed by any parameters yielded by the event.</p> <p>Warning</p> <p>When connecting to the <code>Changed</code> event, be careful not to call <code>setState</code> or other functions that will trigger renders. This will cause Roact to re-render during a render, and errors will be thrown!</p> <p>See the events guide for more details.</p>"},{"location":"api-reference/#roactchange","title":"Roact.Change","text":"<p>Index into <code>Roact.Change</code> to receive a key that can be used to connect to <code>GetPropertyChangedSignal</code> events.</p> <p>It's similar to <code>Roact.Event</code>:</p> <pre><code>Roact.createElement(\"ScrollingFrame\", {\n    [Roact.Change.CanvasPosition] = function(rbx)\n        print(\"ScrollingFrame scrolled to\", rbx.CanvasPosition)\n    end,\n})\n</code></pre> <p>Warning</p> <p>Property changed events are fired by Roact during the reconciliation phase. Be careful not to accidentally trigger a re-render in the middle of a re-render, or an error will be thrown!</p>"},{"location":"api-reference/#roactnone","title":"Roact.None","text":"<p><code>Roact.None</code> is a special value that can be used to clear elements from your component state when calling <code>setState</code> or returning from <code>getDerivedStateFromProps</code>.</p> <p>In Lua tables, removing a field from state is not possible by setting its value to <code>nil</code> because <code>nil</code> values mean the same thing as no value at all. If a field needs to be removed from state, it can be set to <code>Roact.None</code> when calling <code>setState</code>, which will ensure that the resulting state no longer contains it:</p> <pre><code>function MyComponent:didMount()\n    self:setState({\n        fieldToRemove = Roact.None\n    })\nend\n</code></pre>"},{"location":"api-reference/#component-types","title":"Component Types","text":""},{"location":"api-reference/#roactcomponent","title":"Roact.Component","text":"<p>The base component instance that can be extended to make stateful components.</p> <p>Call <code>Roact.Component:extend(\"ComponentName\")</code> to make a new stateful component with a given name.</p>"},{"location":"api-reference/#roactpurecomponent","title":"Roact.PureComponent","text":"<p>An extension of <code>Roact.Component</code> that only re-renders if its props or state change.</p> <p><code>PureComponent</code> implements the <code>shouldUpdate</code> lifecycle event with a shallow equality comparison. It's optimized for use with immutable data structures, which makes it a perfect fit for use with frameworks like Rodux.</p> <p><code>PureComponent</code> is not always faster, but can often result in significant performance improvements when used correctly.</p>"},{"location":"api-reference/#roactportal","title":"Roact.Portal","text":"<p>A component that represents a portal to a Roblox Instance. Portals are created using <code>Roact.createElement</code>.</p> <p>Any children of a portal are put inside the Roblox Instance specified by the required <code>target</code> prop. That Roblox Instance should not be one created by Roact.</p> <p>Portals are useful for creating dialogs managed by deeply-nested UI components, and enable Roact to represent and manage multiple disjoint trees at once.</p> <p>See the Portals guide for a small tutorial and more details about portals.</p>"},{"location":"api-reference/#component-api","title":"Component API","text":""},{"location":"api-reference/#defaultprops","title":"defaultProps","text":"<pre><code>static defaultProps: Dictionary&lt;any, any&gt;\n</code></pre> <p>If <code>defaultProps</code> is defined on a stateful component, any props that aren't specified when a component is created will be taken from there.</p>"},{"location":"api-reference/#init","title":"init","text":"<pre><code>init(initialProps) -&gt; void\n</code></pre> <p><code>init</code> is called exactly once when a new instance of a component is created. It can be used to set up the initial <code>state</code>, as well as any non-<code>render</code> related values directly on the component.</p> <p>Use <code>setState</code> inside of <code>init</code> to set up your initial component state:</p> <pre><code>function MyComponent:init()\n    self:setState({\n        position = 0,\n        velocity = 10\n    })\nend\n</code></pre> <p>In older versions of Roact, <code>setState</code> was disallowed in <code>init</code>, and you would instead assign to <code>state</code> directly. It's simpler to use <code>setState</code>, but assigning directly to <code>state</code> is still acceptable inside <code>init</code>:</p> <pre><code>function MyComponent:init()\n    self.state = {\n        position = 0,\n        velocity = 10\n    }\nend\n</code></pre>"},{"location":"api-reference/#render","title":"render","text":"<pre><code>render() -&gt; Element | nil\n</code></pre> <p><code>render</code> describes what a component should display at the current instant in time.</p> <p>Info</p> <p>Roact assumes that <code>render</code> act likes a pure function: the result of <code>render</code> must depend only on <code>props</code> and <code>state</code>, and it must not have side-effects.</p> <pre><code>function MyComponent:render()\n    -- This is okay:\n    return Roact.createElement(\"TextLabel\", {\n        Text = self.props.text,\n        Position = self.state.position\n    })\n\n    -- Ack! Depending on values outside props/state is not allowed!\n    return Roact.createElement(\"TextLabel\", {\n        Text = self.someText,\n        Position = getMousePosition(),\n    })\nend\n</code></pre> <p><code>render</code> must be defined for all components. The default implementation of <code>render</code> throws an error; if your component does not render anything, define a render function that returns <code>nil</code> explicitly. This helps make sure that you don't forget to define <code>render</code>!</p> <pre><code>function MyComponent:render()\n    return nil\nend\n</code></pre>"},{"location":"api-reference/#setstate","title":"setState","text":"<pre><code>setState(stateUpdater | stateChange) -&gt; void\n</code></pre> <p><code>setState</code> requests an update to the component's state. Roact may schedule this update for a later time or resolve it immediately.</p> <p>If a function is passed to <code>setState</code>, that function will be called with the current state and props as arguments:</p> <pre><code>function MyComponent:didMount()\n    self:setState(function(prevState, props)\n        return {\n            counter = prevState.counter + 1\n        }\n    end)\nend\n</code></pre> <p>If this function returns <code>nil</code>, Roact will not schedule a re-render and no state will be updated.</p> <p>If a table is passed to <code>setState</code>, the values in that table will be merged onto the existing state:</p> <pre><code>function MyComponent:didMount()\n    self:setState({\n        foo = \"bar\"\n    })\nend\n</code></pre> <p>Setting a field in the state to <code>Roact.None</code> will clear it from the state. This is the only way to remove a field from a component's state!</p> <p>Warning</p> <p><code>setState</code> can be called from anywhere except:</p> <ul> <li>Lifecycle hooks: <code>willUnmount</code>, <code>willUpdate</code></li> <li>Pure functions: <code>render</code>, <code>shouldUpdate</code></li> </ul> <p>Calling <code>setState</code> inside of <code>init</code> has special behavior. The result of setState will be used to determine initial state, and no additional updates will be scheduled.</p> <p>Roact may support calling <code>setState</code> in currently-disallowed places in the future.</p> <p>Warning</p> <p><code>setState</code> does not always resolve synchronously! Roact may batch and reschedule state updates in order to reduce the number of total renders.</p> <p>When depending on the previous value of state, like when incrementing a counter, use the functional form to guarantee that all state updates occur!</p> <p>This behavior will be similar to the future behavior of React 17. See:</p> <ul> <li>RFClarification: why is <code>setState</code> asynchronous?</li> <li>Does React keep the order for state updates?</li> </ul>"},{"location":"api-reference/#shouldupdate","title":"shouldUpdate","text":"<pre><code>shouldUpdate(nextProps, nextState) -&gt; bool\n</code></pre> <p><code>shouldUpdate</code> provides a way to override Roact's rerendering heuristics.</p> <p>By default, components are re-rendered any time a parent component updates, or when state is updated via <code>setState</code>.</p> <p><code>PureComponent</code> implements <code>shouldUpdate</code> to only trigger a re-render any time the props are different based on shallow equality. In a future Roact update, all components may implement this check by default.</p>"},{"location":"api-reference/#validateprops","title":"validateProps","text":"<p>Added in Roact 1.0.0</p> <pre><code>static validateProps(props) -&gt; (false, message: string) | true\n</code></pre> <p><code>validateProps</code> is an optional method that can be implemented for a component. It provides a mechanism for verifying inputs passed into the component.</p> <p>Every time props are updated, <code>validateProps</code> will be called with the new props before proceeding to <code>shouldUpdate</code> or <code>init</code>. It should return the same parameters that assert expects: a boolean, true if the props passed validation, false if they did not, plus a message explaining why they failed. If the first return value is true, the second value is ignored.</p> <p>For performance reasons, property validation is disabled by default. To use this feature, enable <code>propValidation</code> via <code>setGlobalConfig</code>:</p> <pre><code>Roact.setGlobalConfig({\n    propValidation = true\n})\n</code></pre> <p>See setGlobalConfig for more details.</p> <p>Note</p> <p><code>validateProps</code> is a static lifecycle method. It does not have access to <code>self</code>, and must be a pure function.</p> <p>Warning</p> <p>Depending on the implementation, <code>validateProps</code> can impact performance. Recommended practice is to enable prop validation during development and leave it off in production environments.</p>"},{"location":"api-reference/#getelementtraceback","title":"getElementTraceback","text":"<pre><code>getElementTraceback() -&gt; string | nil\n</code></pre> <p><code>getElementTraceback</code> gets the stack trace that the component was created in. This allows you to report error messages accurately.</p>"},{"location":"api-reference/#lifecycle-methods","title":"Lifecycle Methods","text":"<p>In addition to the base Component API, Roact exposes additional lifecycle methods that stateful components can hook into to be notified of various steps in the rendering process.</p>"},{"location":"api-reference/#didmount","title":"didMount","text":"<pre><code>didMount() -&gt; void\n</code></pre> <p><code>didMount</code> is fired after the component finishes its initial render. At this point, all associated Roblox Instances have been created, and all components have finished mounting.</p> <p><code>didMount</code> is a good place to start initial network communications, attach events to services, or modify the Roblox Instance hierarchy.</p>"},{"location":"api-reference/#willunmount","title":"willUnmount","text":"<pre><code>willUnmount() -&gt; void\n</code></pre> <p><code>willUnmount</code> is fired right before Roact begins unmounting a component instance's children.</p> <p><code>willUnmount</code> acts like a component's destructor, and is a good place to disconnect any manually-connected events.</p>"},{"location":"api-reference/#willupdate","title":"willUpdate","text":"<pre><code>willUpdate(nextProps, nextState) -&gt; void\n</code></pre> <p><code>willUpdate</code> is fired after an update is started but before a component's state and props are updated.</p>"},{"location":"api-reference/#didupdate","title":"didUpdate","text":"<pre><code>didUpdate(previousProps, previousState) -&gt; void\n</code></pre> <p><code>didUpdate</code> is fired after at the end of an update. At this point, Roact has updated the properties of any Roblox Instances and the component instance's props and state are up to date.</p> <p><code>didUpdate</code> is a good place to send network requests or dispatch Rodux actions, but make sure to compare <code>self.props</code> and <code>self.state</code> with <code>previousProps</code> and <code>previousState</code> to avoid triggering too many updates.</p>"},{"location":"api-reference/#getderivedstatefromprops","title":"getDerivedStateFromProps","text":"<pre><code>static getDerivedStateFromProps(nextProps, lastState) -&gt; nextStateSlice\n</code></pre> <p>Used to recalculate any state that depends on being synchronized with <code>props</code>.</p> <p>Generally, you should use <code>didUpdate</code> to respond to props changing. If you find yourself copying props values to state as-is, consider using props or memoization instead.</p> <p><code>getDerivedStateFromProps</code> should return a table that contains the part of the state that should be updated.</p> <pre><code>function MyComponent.getDerivedStateFromProps(nextProps, lastState)\n    return {\n        someValue = nextProps.someValue\n    }\nend\n</code></pre> <p>As with <code>setState</code>, you can set use the constant <code>Roact.None</code> to remove a field from the state.</p> <p>Note</p> <p><code>getDerivedStateFromProps</code> is a static lifecycle method. It does not have access to <code>self</code>, and must be a pure function.</p> <p>Caution</p> <p><code>getDerivedStateFromProps</code> runs before <code>shouldUpdate</code> and any non-nil return will cause the state table to no longer be shallow-equal. This means that a <code>PureComponent</code> will rerender even if nothing actually changed. Similarly, any component implementing both <code>getDerivedStateFromProps</code> and <code>shouldUpdate</code> needs to do so in a way that takes this in to account.</p>"},{"location":"advanced/bindings-and-refs/","title":"Bindings and Refs","text":"<p>In certain situations, Roact's reconciliation process is ill-suited for managing some Instance properties. For cases like this, Roact provides escape hatches in the form of Bindings and Refs.</p> <p>Bindings and Refs are intended to be used in cases where Roact cannot solve a problem directly, or its solution might not be performant enough, like:</p> <ul> <li>Invoking functions on Roblox Instances</li> <li>Dynamically resizing a host component to fit its contents</li> <li>Gamepad selection</li> <li>Animations</li> </ul>"},{"location":"advanced/bindings-and-refs/#bindings","title":"Bindings","text":"<p>Bindings are special objects that Roact automatically unwraps into values. When a binding is updated, Roact will change only the specific properties that are subscribed to it.</p>"},{"location":"advanced/bindings-and-refs/#binding-properties","title":"Binding Properties","text":"<p>Bindings can be used to provide an external source for a prop value, or to update those values outside of the Roact reconciliation process.</p> <p>First, create a binding and an updater using <code>Roact.createBinding()</code> and put the results somewhere persistent. <code>createBinding</code> returns two results: a binding object and an updater function, which is used to update the binding's value.</p> <pre><code>local Foo = Roact.Component:extend(\"Foo\")\n\nfunction Foo:init()\n    -- createBinding takes an initial value; for our purposes, 0 is fine\n    self.clickCount, self.updateClickCount = Roact.createBinding(0)\nend\n</code></pre> <p>Then, connect the binding value to something that we're rendering and the updater to something that will invoke it.</p> <pre><code>function Foo:render()\n    return Roact.createElement(\"TextButton\", {\n        -- Roact unwraps the binding, sets the Text property to the binding's value,\n        -- and subscribes to the binding\n        Text = self.clickCount,\n        [Roact.Event.Activated] = function()\n            -- When the user clicks the button, the count will be incremented and\n            -- Roact will update any properties that are subscribed to the binding\n            self.updateClickCount(self.clickCount:getValue() + 1)\n        end\n    })\nend\n</code></pre> <p>The result of this example is a <code>TextButton</code> that displays the number of times it's been clicked. In this case, we connect the updater to the button's <code>Activated</code> event. Other use cases could be connecting it to some external property in <code>didMount</code> or passing it to a child component as a callback.</p>"},{"location":"advanced/bindings-and-refs/#mapped-bindings","title":"Mapped Bindings","text":"<p>Often, a binding's value isn't useful by itself. It needs to be transformed into some other value in order to be useful when assigned to an Instance property.</p> <p>Let's modify the above component to make use of a mapped binding:</p> <pre><code>function Foo:render()\n    return Roact.createElement(\"TextButton\", {\n-- Roact will receive the mapped value from the binding\nText = self.clickCount:map(function(value)\nreturn \"Clicks: \" .. tostring(value)\nend),\n[Roact.Event.Activated] = function()\n            -- When the user clicks the button, the count will be incremented\n            self.updateClickCount(self.clickCount:getValue() + 1)\n        end\n    })\nend\n</code></pre> <p>Our mapped binding transforms the number of clicks into a string. Now the <code>TextButton</code> will display \"Clicks: 0\" instead of just the number!</p>"},{"location":"advanced/bindings-and-refs/#refs","title":"Refs","text":"<p>While bindings are most helpful for individual props, we often want to access an entire Roblox Instance and its methods.</p> <p>Refs are a special type of binding that point to Roblox Instance objects that are created by Roact.</p> <p>Refs can only be attached to host components. This is different from React, where refs can be used to call members of composite components.</p>"},{"location":"advanced/bindings-and-refs/#refs-in-action","title":"Refs in Action","text":"<p>To use a ref, call <code>Roact.createRef()</code> and put the result somewhere persistent. Generally, that means that refs are only used inside stateful components.</p> <pre><code>local Foo = Roact.Component:extend(\"Foo\")\n\nfunction Foo:init()\n    self.textBoxRef = Roact.createRef()\nend\n</code></pre> <p>Next, use the ref inside of <code>render</code> by creating a host component. Refs use the special key <code>Roact.Ref</code>.</p> <pre><code>function Foo:render()\n    return Roact.createElement(\"TextBox\", {\n        [Roact.Ref] = self.textBoxRef,\n    })\nend\n</code></pre> <p>Finally, we can use the value of the ref at any point after our component is mounted.</p> <pre><code>function Foo:didMount()\n    -- The actual Instance can be retrieved using the `getValue` method\n    local textBox = self.textBoxRef:getValue()\n\n    print(\"TextBox has this text:\", textBox.Text)\nend\n</code></pre>"},{"location":"advanced/bindings-and-refs/#refs-as-host-properties","title":"Refs as Host Properties","text":"<p>In addition to providing access to underlying Roblox objects, refs also provide a handy shortcut for Roblox Instance properties that expect another Instance as their value. One commonly-encountered example is <code>NextSelectionLeft</code> and its counterparts.</p> <p>Roact's Roblox renderer knows that bindings are not valid Roblox Instance values, so it will unwrap them for you:</p> <pre><code>local Bar = Roact.Component:extend(\"Bar\")\n\nfunction Bar:init()\n    self.leftButtonRef = Roact.createRef()\n    self.rightButtonRef = Roact.createRef()\nend\n\nfunction Bar:render()\n    return Roact.createElement(\"Frame\", nil, {\n        LeftButton = Roact.createElement(\"TextButton\", {\n            [Roact.Ref] = self.leftButtonRef,\n            NextSelectionRight = self.rightButtonRef,\n        }),\n        RightButton = Roact.createElement(\"TextButton\", {\n            [Roact.Ref] = self.rightButtonRef,\n            NextSelectionLeft = self.leftButtonRef,\n        })\n    })\nend\n</code></pre> <p>Since refs use bindings under the hood, they will be automatically updated whenever the ref changes. This means there's no need to worry about the order in which refs are assigned relative to when properties that use them get set.</p>"},{"location":"advanced/bindings-and-refs/#ref-forwarding","title":"Ref Forwarding","text":"<p>In Roact 1.x, refs can only be applied to host components, not stateful or function components. However, stateful or function components may accept a ref in order to pass it along to an underlying host component. In order to implement this, we wrap the given component with <code>Roact.forwardRef</code>.</p> <p>Suppose we have a styled TextBox component that still needs to accept a ref, so that users of the component can trigger functionality like <code>TextBox:CaptureFocus()</code>:</p> <pre><code>local function FancyTextBox(props)\n    return Roact.createElement(\"TextBox\", {\n        Multiline = true,\n        PlaceholderText = \"Enter your text here\",\n        PlaceholderColor3 = Color3.new(0.4, 0.4, 0.4),\n        [Roact.Change.Text] = props.onTextChange,\n    })\nend\n</code></pre> <p>If we were to create an element using the above component, we'd be unable to get a ref to point to the underlying \"TextBox\" Instance:</p> <pre><code>local Form = Roact.Component:extend(\"Form\")\nfunction Form:init()\n    self.textBoxRef = Roact.createRef()\nend\n\nfunction Form:render()\n    return Roact.createElement(FancyTextBox, {\n        onTextChange = function(value)\n            print(\"text value updated to:\", value)\n        end\n        -- This doesn't actually get assigned to the underlying TextBox!\n        [Roact.Ref] = self.textBoxRef,\n    })\nend\n\nfunction Form:didMount()\n    -- Since self.textBoxRef never gets assigned to a host component, this\n    -- doesn't work, and in fact will be an attempt to access a nil reference!\n    self.textBoxRef.current:CaptureFocus()\nend\n</code></pre> <p>In this instance, <code>FancyTextBox</code> simply doesn't do anything with the ref passed into it. However, we can easily update it using forwardRef:</p> <pre><code>local FancyTextBox = Roact.forwardRef(function(props, ref)\n    return Roact.createElement(\"TextBox\", {\n        Multiline = true,\n        PlaceholderText = \"Enter your text here\",\n        PlaceholderColor3 = Color3.new(0.4, 0.4, 0.4),\n        [Roact.Change.Text] = props.onTextChange,\n        [Roact.Ref] = ref,\n    })\nend)\n</code></pre> <p>With the above change, <code>FancyTextBox</code> now accepts a ref and assigns it to the \"TextBox\" host component that it renders under the hood. Our <code>Form</code> implementation will successfully capture focus on <code>didMount</code>.</p>"},{"location":"advanced/bindings-and-refs/#function-refs","title":"Function Refs","text":"<p>The original ref API was based on functions instead of objects (and does not use bindings). Its use is not recommended for most cases anymore.</p> <p>This style of ref involves passing a function as the <code>Roact.Ref</code> prop as opposed to a dedicated ref object:</p> <pre><code>local function Baz(props)\n    return Roact.createElement(\"TextBox\", {\n        [Roact.Ref] = function(instance)\n            -- Be careful to guard against nil refs; this is a gotcha of\n            -- function refs.\n            if instance ~= nil then\n                print(\"TextBox has this text:\", instance.Text)\n            else\n                print(\"TextBox ref removed.\")\n            end\n        end,\n    })\nend\n</code></pre> <p>Warning</p> <p>Function refs, unlike bindings, cannot be used as properties for host components. This will result in an error. </p> <p>Warning</p> <p>When a function ref is called, it's not guaranteed that its sibling or parent components have finished mounting. Causing side effects here can cause difficult-to-trace bugs.</p> <p>Warning</p> <p>When a component with a function ref unmounts, or when the ref value changes, the component's ref is passed <code>nil</code>.</p>"},{"location":"advanced/context/","title":"Context","text":"<p>Added in Roact 1.3.0</p> <ul> <li>Basic Usage</li> <li>Legacy Context</li> </ul> <p>Roact supports a feature called context which enables passing values down the tree without having to pass them through props. Roact's Context API is based on React's Context API.</p> <p>Context is commonly used to implement features like dependency injection, dynamic theming, and scoped state storage.</p>"},{"location":"advanced/context/#basic-usage","title":"Basic Usage","text":"<pre><code>local ThemeContext = Roact.createContext(defaultValue)\n</code></pre> <p>Context objects contain two components, <code>Consumer</code> and <code>Provider</code>.</p> <p>The <code>Consumer</code> component accepts a <code>render</code> function as its only prop, which is used to render its children. It's passed one argument, which is the context value from the nearest matching <code>Provider</code> ancestor.</p> <p>If there is no <code>Provider</code> ancestor, then <code>defaultValue</code> will be passed instead.</p> <pre><code>local function ThemedButton(props)\n    return Roact.createElement(ThemeContext.Consumer, {\n        render = function(theme)\n            return Roact.createElement(\"TextButton\", {\n                Size = UDim2.new(0, 100, 0, 100),\n                Text = \"Click Me!\",\n                TextColor3 = theme.foreground,\n                BackgroundColor3 = theme.background,\n            })\n        end\n    })\nend\n</code></pre> <p>The <code>Provider</code> component accepts a <code>value</code> prop as well as children. Any of its descendants will have access to the value provided to it by using the <code>Consumer</code> component like above.</p> <p>Whenever the <code>Provider</code> receives a new <code>value</code> prop in an update, any attached <code>Consumer</code> components will re-render with the new value. This value could be externally controlled, or could be controlled by state in a component wrapping <code>Provider</code>:</p> <pre><code>local ThemeController = Roact.Component:extend(\"ThemeController\")\n\nfunction ThemeController:init()\n    self:setState({\n        theme = {\n            foreground = Color3.new(1, 1, 1),\n            background = Color3.new(0, 0, 0),\n        }\n    })\nend\n\nfunction ThemeController:render()\n    return Roact.createElement(ThemeContext.Provider, {\n        value = self.state.theme,\n    }, self.props[Roact.Children])\nend\n</code></pre>"},{"location":"advanced/context/#legacy-context","title":"Legacy Context","text":"<p>Danger</p> <p>Legacy Context is a deprecated feature that will be removed in a future release of Roact.</p> <p>Roact also has a deprecated version of context that pre-dates the stable context API.</p> <p>Legacy context values do not update dynamically on their own. It is up to the context user to create their own mechanism for updates, probably using a wrapper component and <code>setState</code>.</p> <p>To use it, add new entries to <code>self._context</code> in <code>Component:init()</code> to create a provider:</p> <pre><code>local Provider = Roact.Component:extend(\"FooProvider\")\n\n-- Using a unique non-string key is recommended to avoid collisions.\nlocal FooKey = {}\n\nfunction Provider:init()\n    self._context[FooKey] = {\n        value = 5,\n    }\nend\n</code></pre> <p>...and read from that same value in <code>Component:init()</code> in your consumer component:</p> <pre><code>local Consumer = Roact.Component:extend(\"FooConsumer\")\n\nfunction Consumer:init()\n    self.foo = self._context[FooKey]\nend\n\nfunction Consumer:render()\n    return Roact.createElement(\"TextLabel\", {\n        Text = \"Foo: \" .. self.foo.value,\n    })\nend\n</code></pre>"},{"location":"advanced/fragments/","title":"Fragments","text":"<p>Fragments are a tool for avoiding unnecessary nesting when organizing components by allowing components to render collections of elements without wrapping them in a single containing element.</p>"},{"location":"advanced/fragments/#without-fragments","title":"Without Fragments","text":"<p>Typically, Roact components will render a single element via <code>createElement</code>. For example, suppose we define a component like this: <pre><code>local function TeamList(props)\n    return Roact.createElement(\"Frame\", {\n        -- Props for Frame...\n    }, {\n        Layout = Roact.createElement(\"UIListLayout\", {\n            -- Props for UIListLayout...\n        })\n        ListItems = Roact.createElement(TeamLabels)\n    })\nend\n</code></pre></p> <p>Suppose we also want to use a separate component to render a collection of <code>TextLabel</code>s: <pre><code>local function TeamLabels(props)\n    return Roact.createElement(\"Frame\", {\n        -- Props for Frame...\n    }, {\n        RedTeam = Roact.createElement(\"TextLabel\", {\n            -- Props for item...\n        }),\n        BlueTeam = Roact.createElement(\"TextLabel\", {\n            -- Props for item...\n        })\n    })\nend\n</code></pre></p> <p>Unfortunately, the <code>TeamLabels</code> component can't return two different labels without wrapping them in a containing frame. The resulting Roblox hierarchy from these <code>TeamList</code> component won't actually apply the <code>UIListLayout</code> to the list of items, because it's grouped incorrectly: <pre><code>Frame:\n    UIListLayout\n    Frame:\n        TextLabel\n        TextLabel\n</code></pre></p>"},{"location":"advanced/fragments/#with-fragments","title":"With Fragments","text":"<p>In order to separate our list contents from our list container, we need to be able to return a group of elements from our render method rather than a single one. Fragments make this possible: <pre><code>local function TeamLabels(props)\nreturn Roact.createFragment({\nRedTeam = Roact.createElement(\"TextLabel\", {\n            -- Props for item...\n        }),\n        BlueTeam = Roact.createElement(\"TextLabel\", {\n            -- Props for item...\n        })\n    })\nend\n</code></pre></p> <p>We provide <code>Roact.createFragment</code> with a table of elements. These elements will result in multiple children of this component's parent. When used in combination with the above <code>TeamList</code> component, it will generate the desired Roblox hierarchy: <pre><code>Frame:\n    UIListLayout\n    TextLabel\n    TextLabel\n</code></pre></p> <p>We are also free to create alternate views that use the same <code>TeamLabels</code> component with different Layouts or groupings.</p>"},{"location":"advanced/portals/","title":"Portals","text":"<p>Portals are a special kind of component provided by Roact that enable components to render objects into a separate, non-Roact Instance.</p> <p>Info</p> <p>Eventually, there will be a diagram of Roact portals here. For now, just imagine Valve's hit game, Portal.</p> <p>To create a portal, use the <code>Roact.Portal</code> component with <code>createElement</code>:</p> <pre><code>local function PartInWorkspace(props)\n    return Roact.createElement(Roact.Portal, {\n        target = Workspace\n    }, {\n        SomePart = Roact.createElement(\"Part\", {\n            Anchored = true\n        })\n    })\nend\n</code></pre> <p>When we create <code>PartInWorkspace</code>, even if it's deep into our Roact tree, a <code>Part</code> Instance named <code>SomePart</code> will be created in <code>Workspace</code>.</p> <p>Warning</p> <p>Portals should only be created to objects that aren't managed by Roact!</p> <p>One particularly good use for portals is full-screen modal dialogs. When we render a modal dialog, we want it to take over the entire screen, but we want components deep in the tree to be able to create them!</p> <pre><code>local PlayerGui = game:GetService(\"Players\").LocalPlayer.PlayerGui\n\n-- Our Modal component is a standard component, but with a portal at the top!\nlocal function Modal(props)\n    return Roact.createElement(Roact.Portal, {\n        target = PlayerGui\n    }, {\n        Modal = Roact.createElement(\"ScreenGui\", {}, {\n            Label = Roact.createElement(\"TextButton\", {\n                Size = UDim2.new(1, 0, 1, 0),\n                Text = \"Click me to close!\",\n\n                [Roact.Event.Activated] = function()\n                    props.onClose()\n                end\n            })\n        })\n    })\nend\n\n-- A ModalButton contains a little bit of state to decide whether the dialog\n-- should be open or not.\nlocal ModalButton = Roact.Component:extend(\"ModalButton\")\n\nfunction ModalButton:init()\n    self.state = {\n        dialogOpen = false\n    }\nend\n\nfunction ModalButton:render()\n    local dialog = nil\n\n    -- If the dialog isn't open, just avoid rendering it.\n    if self.state.dialogOpen then\n        dialog = Roact.createElement(Modal, {\n            onClose = function()\n                self:setState({\n                    dialogOpen = false\n                })\n            end\n        })\n    end\n\n    return Roact.createElement(\"TextButton\", {\n        Size = UDim2.new(0, 400, 0, 300),\n        Text = \"Click me to open modal dialog!\",\n\n        [Roact.Event.Activated] = function()\n            self:setState({\n                dialogOpen = true\n            })\n        end\n    }, {\n        -- If `dialog` ends up nil, this line does nothing!\n        Dialog = dialog\n    })\nend\n</code></pre>"},{"location":"guide/child-merging/","title":"Child Merging","text":"<p>All of the following behaviour can be disabled entirely by setting <code>childMerging</code> to <code>false</code> in <code>Roact:setGlobalConfig()</code>. Functionality will return to being the same as Roblox's version, including any warnings or errors.</p> <p>As mentioned in the elements section, Roblox's version of Roact would remove all children specified in the <code>props[Roact.Children]</code> argument of <code>createElement</code> and only apply the children specified in the <code>children</code> argument if both were specified, and would give you a warning:</p> <pre><code>The prop `Roact.Children` was defined but was overridden by the third parameter to createElement!\nThis can happen when a component passes props through to a child element but also uses the `children` argument:\n\n    Roact.createElement(\"Frame\", passedProps, {\n        child = ...\n    })\n\nInstead, consider using a utility function to merge tables of children together:\n\n    local children = mergeTables(passedProps[Roact.Children], {\n        child = ...\n    })\n\n    local fullProps = mergeTables(passedProps, {\n        [Roact.Children] = children\n    })\n\n    Roact.createElement(\"Frame\", fullProps)\n</code></pre> <p>This version automatically does what the warning suggests you do, by merging <code>props[Roact.Children]</code> and the <code>children</code> argument. By default, the <code>children</code> argument takes precedence over <code>props[Roact.Children]</code> meaning that if there is a child with the same name then it will use the one in <code>children</code>. This can be changed in the global Roact configuration:</p> <pre><code>Roact:setGlobalConfig({\n    propsPrecedence = true\n})\n</code></pre> <p>Warning</p> <p>This behaviour does not apply to children whose key is of type <code>number</code> or those who do not have any key specified. These children are internally added via <code>table.insert</code>, meaning they will be both be added.</p>"},{"location":"guide/components/","title":"Components","text":"<p>Components are encapsulated, reusable pieces of UI that you can combine to build a complete UI.</p> <p>Components accept inputs, known as props, and return elements to describe the UI that should represent those inputs.</p>"},{"location":"guide/components/#types-of-components","title":"Types of Components","text":""},{"location":"guide/components/#host-components","title":"Host Components","text":"<p>A host component is nothing more than a string that matches the name of a Roblox class. We used these in our earlier discussion about elements as the first argument to <code>createElement</code>. Examples include <code>\"Frame\"</code>, <code>\"ImageButton\"</code>, etc.</p> <p>When our component is a host component, the props that we pass to it will be turned directly into properties on the Roblox instance that the component refers to.</p> <p>Info</p> <p>Normally, in Roact, it would error if you passed in a prop to a host component which is not a property on the Roblox instance the host component refers to. In this version, however, it doesn't error as it simply skips over it. This is discussed further in the next section.</p>"},{"location":"guide/components/#function-components","title":"Function Components","text":"<p>Function components are the simplest kind of user-defined component: they're just functions that accept props as their only argument, and return some elements.</p> <pre><code>local function Greeting(props)\n    return Roact.createElement(\"TextLabel\", {\n        Text = \"Hello, \" .. props.name\n    })\nend\n</code></pre>"},{"location":"guide/components/#stateful-components","title":"Stateful Components","text":"<p>Roact also has stateful components, which provide additional features like lifecycle methods and state. We'll talk about these features in a later section.</p> <p>You can create a stateful component by calling <code>Roact.Component:extend</code> and passing in the component's name.</p> <pre><code>local Greeting = Roact.Component:extend(\"Greeting\")\n\nfunction Greeting:render()\n    return Roact.createElement(\"TextLabel\", {\n        Text = \"Hello, \" .. self.props.name\n    })\nend\n</code></pre>"},{"location":"guide/components/#using-components","title":"Using Components","text":"<p>In our previous examples, we passed strings to <code>Roact.createElement</code> to create elements that represented Roblox Instances.</p> <p>We can also pass our custom components to create elements that represent them:</p> <pre><code>local hello = Roact.createElement(Greeting, {\n    name = \"Rick James\"\n})\n</code></pre> <p>The <code>name</code> value is passed to our component as props, which we can reference as the <code>props</code> argument in our function component or <code>self.props</code> in our stateful component.</p>"},{"location":"guide/components/#components-in-components","title":"Components in Components","text":"<p>Components are designed to make it easy to re-use pieces of UI, so naturally, we can use components inside other components!</p> <pre><code>local function Greeting(props)\n    return Roact.createElement(\"TextLabel\", {\n        Text = \"Hello, \" .. props.name\n    })\nend\n\nlocal function GreetEveryone()\n    return Roact.createElement(\"ScreenGui\", {}, {\n        Layout = Roact.createElement(\"UIListLayout\"),\n\n        HelloJoe = Roact.createElement(Greeting, {\n            name = \"Joe\"\n        }),\n\n        HelloMary = Roact.createElement(Greeting, {\n            name = \"Mary\"\n        })\n    })\nend\n</code></pre> <p>Applications built using Roact usually have one component at the top of the tree, and include all other pieces as children.</p>"},{"location":"guide/components/#incrementing-counter-part-two","title":"Incrementing Counter, Part Two","text":"<p>We can revisit the incrementing counter example from the previous section, now using a function component. Changed sections are highlighted.</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\n\nlocal Roact = require(ReplicatedStorage.Roact)\n\n-- Create a function component that represents our UI\nlocal function Clock(props)\nlocal currentTime = props.currentTime\nreturn Roact.createElement(\"ScreenGui\", {}, {\n        TimeLabel = Roact.createElement(\"TextLabel\", {\n            Size = UDim2.new(1, 0, 1, 0),\n            Text = \"Time Elapsed: \" .. currentTime\n        })\n    })\nend\n\nlocal PlayerGui = Players.LocalPlayer.PlayerGui\n\n-- Create our initial UI.\nlocal currentTime = 0\n\nlocal clockElement = Roact.createElement(Clock, {\ncurrentTime = currentTime\n})\nlocal handle = Roact.mount(clockElement, PlayerGui, \"Clock UI\")\n-- Every second, update the UI to show our new time.\nwhile true do\n    wait(1)\n\n    currentTime = currentTime + 1\nhandle = Roact.update(handle, Roact.createElement(Clock, {\ncurrentTime = currentTime\n}))\nend\n</code></pre>"},{"location":"guide/elements/","title":"Elements","text":"<p>Like React, everything in Roact is built out of elements. Elements are the smallest building blocks for creating UI.</p> <p>Elements describe what you want your UI to look like at a single point in time. They're immutable: you can't change elements once they're created, but you can create new ones. Because creating elements is fast, this is no big deal.</p> <p>You can create an element using <code>Roact.createElement</code>. You will need to pass it a Roblox class name as the first argument (this is a kind of component, which we discuss in the components section, and any properties as the second argument!</p> <pre><code>local myElement = Roact.createElement(\"Frame\", {\n    Size = UDim2.new(0, 50, 0, 50)\n})\n</code></pre> <p>You can also represent children by passing them to the optional third argument of <code>createElement</code>:</p> <pre><code>local myElement = Roact.createElement(\"Frame\", {\n    Size = UDim2.new(0, 50, 0, 50)\n}, {\n    SomeChild = Roact.createElement(\"TextLabel\", {\n        Text = \"Hello, Roact!\"\n    })\n})\n</code></pre> <p>or by applying <code>Roact.Children</code> as a prop:</p> <pre><code>local myElement = Roact.createElement(\"Frame\", {\n    Size = UDim2.new(0, 50, 0, 50),\n    [Roact.Children] = {\n        SomeChild = Roact.createElement(\"TextLabel\", {\n            Text = \"Hello, Roact!\"\n        })\n    }\n})\n</code></pre> <p>Info</p> <p>Normally, in Roact, if you specified both the <code>Roact.Children</code> prop and the third argument, the third argument would take precedence in that it would entirely replace whatever was passed in as <code>Roact.Children</code> in <code>props</code>. However, in this version, it automatically merges the two. This is discussed further in the next section.</p> <p>Creating an element by itself doesn't do anything, however. In order to turn our description of an object into a real Roblox Instance, we can call <code>Roact.mount</code>:</p> <pre><code>-- Create a new Frame object in 'Workspace'\nlocal myHandle = Roact.mount(myElement, game.Workspace)\n</code></pre> <p>Mounting is the process of creating a Roact component instance as well as any associated Roblox Instances.</p> <p><code>Roact.mount</code> returns a handle that we can later use to update or destroy that object with <code>Roact.update</code> and <code>Roact.unmount</code>.</p>"},{"location":"guide/elements/#changing-whats-rendered","title":"Changing What's Rendered","text":"<p>In order to change the UI that we've created, we need to create a new set of elements and update the existing tree to match it.</p> <p>Reconciliation is the term that Roact uses to describe the process of updating an existing UI to match what the program wants it to look like at any given time.</p> <p>Using <code>myHandle</code> from above, we can update the size and text of our label:</p> <pre><code>-- Make some new elements that describe what our new UI will look like.\nlocal myNewElement = Roact.createElement(\"Frame\", {\n    Size = UDim2.new(0, 100, 0, 50)\n}, {\n    SomeChild = Roact.createElement(\"TextLabel\", {\n        Text = \"Hello, again, Roact!\"\n    })\n})\n\n-- Update our hierarchy to match those elements.\nmyHandle = Roact.update(myHandle, myNewElement)\n</code></pre> <p>Info</p> <p>Most projects using UI don't use <code>Roact.update</code> and instead change UI using state and lifecycle events, which will be introduced in the next section.</p> <p><code>Roact.update</code> is mostly useful to embed Roact components into existing, non-Roact projects, and for introducing Roact!</p> <p>Unlike many other UI systems, Roact doesn't let you directly set values on UI objects. Instead, describe what your UI should look like in the form of elements and Roact will handle changing the underlying Roblox Instances.</p>"},{"location":"guide/elements/#unmounting-the-tree","title":"Unmounting the Tree","text":"<p>Roact provides a method called <code>Roact.unmount</code> that we can use when we're finished with our tree.</p> <pre><code>Roact.unmount(myHandle)\n</code></pre> <p>Unmounting destructs the given Roact component instance and destroys any associated Roblox Instances with it.</p> <p>Warning</p> <p>Trying to use a handle after it's been passed to <code>Roact.unmount</code> will result in errors!</p>"},{"location":"guide/elements/#incrementing-counter","title":"Incrementing Counter","text":"<p>Using what's been covered so far, we can make a simple program that tells you how long it has been running.</p> <p>This is a complete example that should work when put into a <code>LocalScript</code> in <code>StarterPlayerScripts</code>. It assumes Roact has been installed into <code>ReplicatedStorage</code>.</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\n\nlocal Roact = require(ReplicatedStorage.Roact)\n\n-- Create a function that creates the elements for our UI.\n-- Later, we'll use components, which are the best way to organize UI in Roact.\nlocal function clock(currentTime)\n    return Roact.createElement(\"ScreenGui\", {}, {\n        TimeLabel = Roact.createElement(\"TextLabel\", {\n            Size = UDim2.new(1, 0, 1, 0),\n            Text = \"Time Elapsed: \" .. currentTime\n        })\n    })\nend\n\nlocal PlayerGui = Players.LocalPlayer.PlayerGui\n\n-- Create our initial UI.\nlocal currentTime = 0\nlocal handle = Roact.mount(clock(currentTime), PlayerGui, \"Clock UI\")\n\n-- Every second, update the UI to show our new time.\nwhile true do\n    wait(1)\n\n    currentTime = currentTime + 1\n    handle = Roact.update(handle, clock(currentTime))\nend\n</code></pre> <p>In the next section, we'll talk about components, which let us create reusable chunks of UI, and introduce the primary technique to change UI in Roact.</p>"},{"location":"guide/events/","title":"Events","text":"<p>Roact manages Instance event connections automatically as part of rendering.</p> <p>To connect to an event, pass a prop with <code>Roact.Event.EVENT_NAME</code> as the key and a function as the value.</p> <p>Roact will pass the instance that the event is connected to as the first argument to the event callback, followed by any arguments that Roblox passed in.</p> <pre><code>local button = Roact.createElement(\"TextButton\", {\n    Text = \"Click me!\",\n    Size = UDim2.new(0, 400, 0, 300),\n\n    [Roact.Event.MouseButton1Click] = function(rbx)\n        print(\"The button was clicked!\")\n    end\n})\n</code></pre> <p>Info</p> <p>Events will automatically be disconnected when a component instance is unmounted!</p> <p>To listen to <code>GetPropertyChangedSignal</code>, Roact provides a similar API, using props like <code>Roact.Change.PROPERTY_NAME</code>:</p> <pre><code>local frame = Roact.createElement(\"Frame\", {\n    [Roact.Change.AbsoluteSize] = function(rbx)\n        print(\"Absolute size changed to\", rbx.AbsoluteSize)\n    end\n})\n</code></pre> <p>Warning</p> <p>Roact can trigger events while updating the tree! If Roact triggers an event handler that calls <code>setState</code> synchronously, an error will be thrown. In the future, Roact may delay evaluation of event handlers to prevent them from happening while Roact is modifying the tree.</p>"},{"location":"guide/hello-roact/","title":"Hello, Roact!","text":"<p>Info</p> <p>These examples assumes that you've successfully installed Roact into <code>ReplicatedStorage</code>!</p> <p>Add a new <code>LocalScript</code> object to <code>StarterPlayer.StarterPlayerScripts</code> either in Roblox Studio, or via Rojo:</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\n\nlocal Roact = require(ReplicatedStorage.Roact)\n\nlocal app = Roact.createElement(\"ScreenGui\", {}, {\n    HelloWorld = Roact.createElement(\"TextLabel\", {\n        Size = UDim2.new(0, 400, 0, 300),\n        Text = \"Hello, Roact!\"\n    })\n})\n\nRoact.mount(app, Players.LocalPlayer.PlayerGui)\n</code></pre> <p>When you run your game, you should see a large gray label with the phrase 'Hello, Roact!' appear on screen!</p>"},{"location":"guide/installation/","title":"Installation","text":"<p>There are two supported ways to get started with Roact.</p> <p>For our examples, we'll install <code>Roact</code> to <code>ReplicatedStorage</code>. In practice, it's okay to install Roact anywhere you want!</p>"},{"location":"guide/installation/#method-1-model-file-roblox-studio","title":"Method 1: Model File (Roblox Studio)","text":"<ul> <li>Download the <code>rbxm</code> model file attached to the latest release from the GitHub releases page.</li> <li>Insert the model into Studio into a place like <code>ReplicatedStorage</code></li> </ul>"},{"location":"guide/installation/#method-2-filesystem","title":"Method 2: Filesystem","text":"<ul> <li>Copy the <code>src</code> directory into your codebase</li> <li>Rename the folder to <code>Roact</code></li> <li>Use a plugin like Rojo to sync the files into a place</li> </ul>"},{"location":"guide/invalid-prop-discarding/","title":"Invalid Prop Discarding","text":"<p>All of the following behaviour can be disabled entirely by setting <code>invalidPropDiscarding</code> to <code>false</code> in <code>Roact:setGlobalConfig()</code>. Functionality will return to being the same as Roblox's version, including any warnings or errors.</p> <p>As mentioned in the last section, passing in an invalid prop into a host component does not error like in regular Roact. While this has its drawbacks \u2014 notably making it harder to spot invalid props intended to actually be properties and the inability to use <code>typeChecks</code> \u2014 this helps massively with overriding a component's default props without having to use sanitiser functions.</p>"},{"location":"guide/invalid-prop-discarding/#why","title":"Why?","text":"<p>Normally, to override default component props, you might do the following:</p> <pre><code>-- component code\nfunction Button(props)\n    local fullProps = {\n        BackgroundColor3 = Color3.new(1, 0, 1),\n        Size = UDim2.new(0, 100, 0, 50),\n        Text = \"Placeholder text\",\n        TextColor3 = Color3.new(1, 1, 1),\n        TextStrokeColor3 = Color3.new(0, 0, 0),\n    }\n\n    for k, v in props do\n        fullProps[k] = v\n    end\n\n    return Roact.createElement(\"TextButton\", fullProps)\nend\n</code></pre> <pre><code>-- adding to/overriding default props\nlocal buttonElement = Roact.createElement(Button, {\n    AnchorPoint = Vector2.new(0.5, 0.5),\n    Size = UDim2.new(0, 600, 0, 400),\n    Text = \"Overriden text\",\n})\n</code></pre> <p>This can work at first, but issues arise when you want to use props other than the host components available properties:</p> <pre><code>function Button(props)\n    local fullProps = {\n        BackgroundColor3 = Color3.new(1, 0, 1),\nFontFace = Font.fromName(\"FredokaOne\", props.FontStyle)\nSize = UDim2.new(0, 100, 0, 50),\n        Text = \"Placeholder text\",\n        TextColor3 = Color3.new(1, 1, 1),\n        TextStrokeColor3 = Color3.new(0, 0, 0),\n    }\n\n    for k, v in props do\n        fullProps[k] = v\n    end\n\n    return Roact.createElement(\"TextButton\", fullProps)\nend\n</code></pre> <p>This code looks fine at first, but during the <code>for</code> loop, it gets added to <code>fullProps</code>, thereby passing it as a prop into <code>TextButton</code>, which will error. You could override the <code>FontFace</code> prop itself, but if you ever want to change the font across the whole game (or at least every <code>Button</code>), then you have to go change every override of it instead of just in the component itself. The hassle of this stacks up the more complex your components are. The same applies to adding an exception for <code>FontStyle</code> in the <code>for</code> loop, but again the more invalid props there are, the larger the hassle of this is.</p> <p>Another point at which this becomes a drag is when there are multiple versions of the same component, e.g. a secondary button. You could make a <code>BaseButton</code> component and extend your primary and secondary buttons from that, but should you also introduce active and inactive buttons, you'll have to make 4 separate components, which all have to incorporate the same merger <code>for</code> loop or any other shared logic across them, which isn't very D.R.Y.</p> <p>Sometimes, invalid props may even have nothing to do with the actual style of the component itself, instead incorporating some other logic in them. In this example, it fires a <code>RemoteEvent</code>:</p> <pre><code>function Button(props)\n    local fullProps = {\n        BackgroundColor3 = Color3.new(1, 0, 1),\n        Size = UDim2.new(0, 100, 0, 50),\n        Text = \"Placeholder text\",\n        TextColor3 = Color3.new(1, 1, 1),\n        TextStrokeColor3 = Color3.new(0, 0, 0),\n    }\n\nif props.IsASpecialButton then\nReplicatedStorage.RemoteEvent:FireServer(\"Special button rendered!\")\nend\nfor k, v in props do\n        fullProps[k] = v\n    end\n\n    return Roact.createElement(\"TextButton\", fullProps)\nend\n</code></pre> <p>In cases such as these, it's mostly a convenience for Roact to simply skip over invalid props when applying them to actual Roblox instances, rather than create impractical workarounds to both be able to add to and override default component props and incorporate extra logic based on props.</p>"},{"location":"guide/state-and-lifecycle/","title":"State and Lifecycle","text":"<p>In the previous section, we talked about using components to create reusable chunks of state, and introduced host, function, and stateful components.</p> <p>Stateful components do everything that function components do, but have the addition of mutable state and lifecycle methods.</p>"},{"location":"guide/state-and-lifecycle/#state","title":"State","text":"<p>State is the term we use to talk about values that are owned by a component itself.</p> <p>Unlike props, which are passed to a component from above, state is created within a component and can only be updated by that component.</p> <p>We can set up the initial state of a stateful component inside of a method named <code>init</code>:</p> <pre><code>function MyComponent:init()\n    self:setState({\n        currentTime = 0\n    })\nend\n</code></pre> <p>To update state, we use a special method named <code>setState</code>. <code>setState</code> will merge any values we give it into our state. It will overwrite any existing values, and leave any values we don't specify alone.</p> <p>There's another form of <code>setState</code> we can use. When the new state we want our component to have depends on our current state, like incrementing a value, we use this form:</p> <pre><code>-- This is another special method, didMount, that we'll talk about in a moment.\nfunction MyComponent:didMount()\n    self:setState(function(state)\n        return {\n            currentTime = 1 + state.currentTime\n        }\n    end)\nend\n</code></pre> <p>In this case, we're passing a function to <code>setState</code>. This function is called and passed the current state, and returns a new state. It can also return <code>nil</code> to abort the state update, which lets Roact make some handy optimizations.</p> <p>Right now, this version of <code>setState</code> works exactly the same way as the version that accepts an object. In the future, Roact will support optimizations that make this difference more important, like asynchronous rendering.</p>"},{"location":"guide/state-and-lifecycle/#lifecycle-methods","title":"Lifecycle Methods","text":"<p>Stateful components can provide methods to Roact that are called when certain things happen to a component instance.</p> <p>Lifecycle methods are a great place to send off network requests, measure UI (with the help of refs), wrap non-Roact components, and produce other side-effects.</p> <p>The most useful lifecycle methods are generally <code>didMount</code> and <code>didUpdate</code>. Most components that do things that are difficult to express in Roact itself will use these lifecycle methods.</p> <p>Here's a chart of all of the methods available. You can also check out the Lifecycle Methods section of the API reference for more details.</p>"},{"location":"guide/state-and-lifecycle/#incrementing-counter-part-three","title":"Incrementing Counter, Part Three","text":"<p>Building on the previous two examples, we can expand the incrementing counter to move the counter state and loop inside Roact, and use <code>setState</code> to trigger a re-render instead of <code>Roact.update</code>.</p> <p>Generally, this ticking clock demonstrates how many stateful components are structured in Roact.</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\n\nlocal Roact = require(ReplicatedStorage.Roact)\n\nlocal Clock = Roact.Component:extend(\"Clock\")\n\nfunction Clock:init()\n    -- In init, we can use setState to set up our initial component state.\n    self:setState({\n        currentTime = 0\n    })\nend\n\n-- This render function is almost completely unchanged from the first example.\nfunction Clock:render()\n    -- As a convention, we'll pull currentTime out of state right away.\n    local currentTime = self.state.currentTime\n\n    return Roact.createElement(\"ScreenGui\", {}, {\n        TimeLabel = Roact.createElement(\"TextLabel\", {\n            Size = UDim2.new(1, 0, 1, 0),\n            Text = \"Time Elapsed: \" .. currentTime\n        })\n    })\nend\n\n-- Set up our loop in didMount, so that it starts running when our\n-- component is created.\nfunction Clock:didMount()\n    -- Set a value that we can change later to stop our loop\n    self.running = true\n\n    -- We don't want to block the main thread, so we spawn a new one!\n    spawn(function()\n        while self.running do\n            -- Because we depend on the previous state, we use the function\n            -- variant of setState. This will matter more when Roact gets\n            -- asynchronous rendering!\n            self:setState(function(state)\n                return {\n                    currentTime = state.currentTime + 1\n                }\n            end)\n\n            wait(1)\n        end\n    end)\nend\n\n-- Stop the loop in willUnmount, so that our loop terminates when the\n-- component is destroyed.\nfunction Clock:willUnmount()\n    self.running = false\nend\n\nlocal PlayerGui = Players.LocalPlayer.PlayerGui\n\n-- Create our UI, which now runs on its own!\nlocal handle = Roact.mount(Roact.createElement(Clock), PlayerGui, \"Clock UI\")\n\n-- Later, we can destroy our UI and disconnect everything correctly.\nwait(10)\nRoact.unmount(handle)\n</code></pre>"},{"location":"performance/overview/","title":"Overview","text":"<p>Roact operates on the principle that it's much easier to build UI declaratively. When something changes, the UI is rebuilt virtually and then the minimal necessary changes are made to the actual UI elements.</p> <p>For simple projects, performance is unlikely to be an issue. But Roact is built in Lua, and Lua can be slow. The following pages provide a number of techniques and best practices that you can employ to avoid performance strain with your Roact apps.</p>"},{"location":"performance/reduce-reconciliation/","title":"Reduce Reconciliation","text":"<p>In all likelihood, the primary source of performance gains for your app will come from reducing the amount of work that Roact's reconciliation process requires. This is accomplished by:</p> <ul> <li>Indicating to Roact that some reconciliation work can be skipped</li> <li>Making sure your elements only change in ways you intended</li> </ul>"},{"location":"performance/reduce-reconciliation/#shouldupdate-lifecycle-method","title":"<code>shouldUpdate</code> Lifecycle Method","text":"<p>When a Roact Component's state or props change, it will call the Component's <code>shouldUpdate</code> method to determine whether or not to re-render it. The default implementation will always return true. <pre><code>function Component:shouldUpdate(newProps, newState)\n    return true\nend\n</code></pre></p> <p>If you have a more complex component that only needs to re-render in certain situations, you can either use <code>PureComponent</code> (discussed below) or implement your own <code>shouldUpdate</code> and return <code>false</code> in any case where an update is not required.</p> <p>Warning</p> <p>Manually implementing <code>shouldUpdate</code> is dangerous! If done carelessly, it can easily create confusing or subtle bugs.</p> <p>In most cases, the preferable solution is to use <code>PureComponent</code> instead, which has a simple and robust implementation of <code>shouldUpdate</code>.</p>"},{"location":"performance/reduce-reconciliation/#purecomponent","title":"<code>PureComponent</code>","text":"<p>One common implementation of <code>shouldUpdate</code> is to do a shallow comparison between current and previous props and state. <code>Roact</code> provides an extension of <code>Roact.Component</code> called <code>Roact.PureComponent</code> that uses this implementation.</p> <p>Let's use the following example: <pre><code>local Item = Roact.Component:extend(\"Item\")\n\nfunction Item:render()\n    local icon = self.props.icon\n    local layoutOrder = self.props.layoutOrder\n\n    -- Create a list item with the item's icon and name\n    return Roact.createElement(\"ImageLabel\", {\n        LayoutOrder = layoutOrder,\n        Image = icon,\n    })\nend\n\nlocal Inventory = Roact.Component:extend(\"Inventory\")\n\nfunction Inventory:render()\n    -- An Inventory contains a list of items\n    local items = self.state.items\n\n    local itemList = {}\n    -- Create a UIListLayout to space out our items\n    itemList[\"Layout\"] = Roact.createElement(\"UIListLayout\", {\n        SortOrder = Enum.SortOrder.LayoutOrder,\n        FillDirection = Enum.FillDirection.Vertical,\n    })\n    for i, item in ipairs(items) do\n        -- Add the element to our list\n        itemList[i] = Roact.createElement(Item, {\n            layoutOrder = i,\n            icon = item.icon,\n        })\n    end\n\n    -- The Inventory renders a frame containing the list of Items as children\n    return Roact.createElement(\"Frame\", {\n        Size = UDim2.new(0, 200, 0, 400)\n    }, itemList)\nend\n</code></pre></p> <p>In the above example, adding a new item to the <code>items</code> prop of the <code>Inventory</code> would cause all of the child <code>Item</code> elements to re-render, even if they haven't changed at all. This means if you add an item to an <code>Inventory</code> that already has 5 items, the result will be 6 renders of the <code>Item</code> component.</p> <p>Lets change <code>Item</code> to a <code>PureComponent</code>: <pre><code>local Item = Roact.PureComponent:extend(\"Item\")\n</code></pre> Now, if we add a new item to the end of the <code>Inventory</code> or change something about an existing item, we'll only re-render the <code>Inventory</code> itself and the modified <code>Item</code>!</p> <p>Warning</p> <p>When working with <code>PureComponent</code>, it's critical to use immutable props. Immutability guarantees that a prop's reference will change any time its contents change.</p> <p>Info</p> <p>There's more to discuss about immutability. It deserves a fully fleshed-out section somewhere!</p>"},{"location":"performance/reduce-reconciliation/#stable-keys","title":"Stable Keys","text":"<p>Another performance improvement we can make is to use stable, unique keys to refer to our child elements.</p> <p>When the list that we pass into the <code>Inventory</code> component changes, Roact updates our Roblox UI by adjusting the properties of each Roblox Instance according to the new list of elements.</p> <p>For example, let's suppose our list of items is as follows: <pre><code>{\n    { id = \"sword\", icon = swordIcon }, -- [1]\n    { id = \"shield\", icon = shieldIcon }, -- [2]\n}\n</code></pre></p> <p>If we add a new item to the beginning, then we'll end up with a list like this: <pre><code>{\n    { id = \"potion\", icon = potionIcon } -- [1]\n    { id = \"sword\", icon = swordIcon }, -- [2]\n    { id = \"shield\", icon = shieldIcon }, -- [3]\n}\n</code></pre></p> <p>When Roact updates the underlying <code>ImageLabel</code> objects, it will need to change their icons so that the item at <code>[1]</code> has the potion icon, the item at <code>[2]</code> has the sword icon, and a new <code>ImageLabel</code> is added at <code>[3]</code> with the shield icon.</p> <p>We'd like for Roact to know that the new item was added at <code>[1]</code> and that the sword and shield items simply moved down in the list. That way it can adjust their LayoutOrder properties and let the Roblox UI system resolve the rest.</p> <p>So let's fix it! We'll make our list of <code>Item</code> elements use the item's id for its keys instead of the indexes in the <code>items</code> list:</p> <pre><code>function Inventory:render()\n    -- An Inventory contains a list of items\n    local items = self.state.items\n\n    local itemList = {}\n    itemList[\"Layout\"] = Roact.createElement(\"UIListLayout\", {\n        SortOrder = Enum.SortOrder.LayoutOrder,\n        FillDirection = Enum.FillDirection.Vertical,\n    })\n    for i, item in ipairs(items) do\n-- Each element is now added at a stable key\nitemList[item.id] = Roact.createElement(Item, {\nlayoutOrder = i,\n            icon = item.icon,\n        })\n    end\n\n    -- The Inventory renders a frame containing the list of Items as children\n    return Roact.createElement(\"Frame\", {\n        Size = UDim2.new(0, 200, 0, 400)\n    }, itemList)\nend\n</code></pre> <p>Now the list of children is keyed by the stable, unique id of the item data. Their positions can change according to their LayoutOrder, but no other properties on the item need to be updated. When we add the third element to the list, Roact will set the <code>LayoutOrder</code> property on for each <code>ImageLabel</code> and only set the <code>Image</code> property on the newly added one!</p> <p>Info</p> <p>Switching to static keys might seem insignificant for this example, but if our <code>Item</code> component becomes more complicated and our inventory gets bigger, it can make a significant difference!</p>"}]}